<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled 3D Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-container { position: absolute; top: 10px; left: 10px; z-index: 2; opacity: 0.8; transform: scaleX(-1); border: 2px solid #333; border-radius: 8px; overflow: hidden; }
        video { width: 160px; height: 120px; object-fit: cover; display: block; }
        #ui { position: absolute; bottom: 20px; left: 20px; z-index: 3; color: white; pointer-events: none; }
        h1 { font-size: 1.2rem; margin: 0 0 5px 0; text-transform: uppercase; letter-spacing: 2px; }
        p { font-size: 0.9rem; color: #aaa; margin: 0; }
        .status { color: #00ff88; font-weight: bold; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="video-container">
        <video id="input-video"></video>
    </div>
    <div id="canvas-container"></div>

    <div id="ui">
        <h1>Hand Particle Control</h1>
        <p>üñê <b>Open Hand:</b> Expand Particles</p>
        <p>‚úä <b>Closed Fist:</b> Switch Shape</p>
        <p>Current Shape: <span id="shape-name" class="status">Loading...</span></p>
    </div>

<script>
    // --- 1. CONFIGURATION & STATE ---
    const PARTICLE_COUNT = 8000;
    const PARTICLE_SIZE = 0.15;
    
    const state = {
        currentShape: 0,
        shapes: ['Sphere', 'Heart', 'Saturn', 'Flower', 'Torus'],
        isFist: false,
        handX: 0,
        handY: 0,
        handOpenness: 1, // 0 to 1
        lastSwitchTime: 0
    };

    // --- 2. THREE.JS SETUP ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 30;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Particle Geometry
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3);

    // Initialize positions randomly
    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 50;
        colors[i] = 1; 
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.8
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 3. SHAPE GENERATORS ---
    // Helper to map index to 3D point
    function getSpherePoint(i) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);
        const r = 10;
        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi)
        };
    }

    function getHeartPoint(i) {
        // Parametric Heart Equation
        let t = Math.random() * Math.PI * 2; // Theta
        let p = Math.random() * Math.PI; // Phi (distribution adjustment)
        
        // Use rejection sampling or specialized distribution for volume
        // Simplified surface approximation:
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        const z = (Math.random() - 0.5) * 4; // Thickness
        
        const scale = 0.5;
        return { x: x * scale, y: y * scale, z: z };
    }

    function getSaturnPoint(i) {
        const isRing = Math.random() > 0.4; // 60% ring, 40% planet
        if (isRing) {
            const theta = Math.random() * Math.PI * 2;
            const r = 12 + Math.random() * 6; // Ring radius
            return {
                x: r * Math.cos(theta),
                y: (Math.random() - 0.5) * 0.5, // Thin ring
                z: r * Math.sin(theta)
            };
        } else {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const r = 6; // Planet radius
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
            };
        }
    }

    function getFlowerPoint(i) {
        const u = Math.random() * Math.PI * 2;
        const v = Math.random() * Math.PI;
        const r = 10 * Math.sin(3 * u) * Math.sin(v); // 3-petal rose shape
        return {
            x: r * Math.sin(u) * Math.cos(v),
            y: r * Math.cos(u),
            z: r * Math.sin(u) * Math.sin(v)
        };
    }

    function getTorusPoint(i) {
        const u = Math.random() * Math.PI * 2;
        const v = Math.random() * Math.PI * 2;
        const R = 8; // Major radius
        const r = 3; // Minor radius
        return {
            x: (R + r * Math.cos(v)) * Math.cos(u),
            y: (R + r * Math.cos(v)) * Math.sin(u),
            z: r * Math.sin(v)
        };
    }

    const shapeGenerators = [getSpherePoint, getHeartPoint, getSaturnPoint, getFlowerPoint, getTorusPoint];

    function updateTargetShape(shapeIndex) {
        document.getElementById('shape-name').innerText = state.shapes[shapeIndex];
        const generator = shapeGenerators[shapeIndex];
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const p = generator(i);
            targetPositions[i * 3] = p.x;
            targetPositions[i * 3 + 1] = p.y;
            targetPositions[i * 3 + 2] = p.z;
        }
    }

    // Initial shape
    updateTargetShape(0);


    // --- 4. MEDIAPIPE HANDS SETUP ---
    const videoElement = document.getElementById('input-video');

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];

            // 1. Calculate Hand Center (Screen Space 0-1)
            // Wrist is index 0, Middle finger knuckle is 9
            const x = landmarks[9].x; 
            const y = landmarks[9].y;
            
            // Map to -1 to 1 for Three.js
            state.handX = (x - 0.5) * 2;
            state.handY = -(y - 0.5) * 2;

            // 2. Detect Fist vs Open Hand
            // Check distance between wrist (0) and finger tips (8, 12, 16, 20)
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20]; // Index, Middle, Ring, Pinky
            let avgDist = 0;
            tips.forEach(idx => {
                const dx = landmarks[idx].x - wrist.x;
                const dy = landmarks[idx].y - wrist.y;
                avgDist += Math.sqrt(dx*dx + dy*dy);
            });
            avgDist /= 4;

            // Heuristic: If average tip distance to wrist is small, it's a fist
            const FIST_THRESHOLD = 0.25; 
            const isFistNow = avgDist < FIST_THRESHOLD;

            // Debounced Shape Switching
            const now = Date.now();
            if (isFistNow && !state.isFist && (now - state.lastSwitchTime > 1000)) {
                // Trigger Switch
                state.currentShape = (state.currentShape + 1) % state.shapes.length;
                updateTargetShape(state.currentShape);
                state.lastSwitchTime = now;
            }
            state.isFist = isFistNow;

            // 3. Calculate Expansion Factor (Thumb to Index)
            // Used for dynamic expansion when hand is open
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const dist = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) + 
                Math.pow(thumbTip.y - indexTip.y, 2)
            );
            
            // Map pinch distance to expansion (0 to 1 range approx)
            state.handOpenness = Math.min(Math.max(dist * 5, 0.5), 2.5);
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });
    cameraUtils.start();


    // --- 5. ANIMATION LOOP ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const time = clock.getElapsedTime();
        const positionsAttribute = geometry.attributes.position;
        const colorsAttribute = geometry.attributes.color;

        // Interaction Logic
        // Rotate the entire particle system based on hand position
        particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, state.handX, 0.05);
        particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, state.handY, 0.05);

        // Particle dynamics
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const px = positionsAttribute.getX(i);
            const py = positionsAttribute.getY(i);
            const pz = positionsAttribute.getZ(i);

            const tx = targetPositions[i * 3];
            const ty = targetPositions[i * 3 + 1];
            const tz = targetPositions[i * 3 + 2];

            // 1. Move towards target shape (Lerp)
            // If fist is clenched, we might tighten the shape (lerp faster or stick closer)
            // If hand is open, we expand the target coordinates
            
            let expansion = state.isFist ? 0.8 : state.handOpenness;
            
            // Interpolate position
            // Smoothly move current pos towards (target * expansion)
            const lerpSpeed = 0.03 + (Math.random() * 0.02);
            
            positionsAttribute.setXYZ(i, 
                px + ((tx * expansion) - px) * lerpSpeed,
                py + ((ty * expansion) - py) * lerpSpeed,
                pz + ((tz * expansion) - pz) * lerpSpeed
            );

            // 2. Dynamic Color
            // Color shifts based on time and position
            const r = Math.sin(time * 0.5 + px * 0.1) * 0.5 + 0.5;
            const g = Math.cos(time * 0.3 + py * 0.1) * 0.5 + 0.5;
            const b = Math.sin(time * 0.7 + pz * 0.1) * 0.5 + 0.5;

            // If fist, turn red/orange
            if (state.isFist) {
                 colorsAttribute.setXYZ(i, 1.0, 0.2, 0.1);
            } else {
                 colorsAttribute.setXYZ(i, r, g, b);
            }
        }

        positionsAttribute.needsUpdate = true;
        colorsAttribute.needsUpdate = true;
        
        // Gentle rotation if idle
        if (state.handX === 0 && state.handY === 0) {
            particles.rotation.y += 0.002;
        }

        renderer.render(scene, camera);
    }

    animate();

    // Handle Window Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
